---
title: Configuring `step-ca` Templates
html_title: Configuring open source step-ca Templates
description: Learn how to configure step-ca Templates
updated_at: April 03, 2025
---

People use private CAs for all sorts of things, in many different contexts:
web apps, mobile apps, code signing, cloud VM instances, SSH, IoT devices, etc.
So `step-ca` must be flexible enough to handle a wide variety of flows.

X.509 and SSH certificate templates open up these possibilities.
With certificate templates, you can do things like:

- Add extensions (OIDs) to X.509 certificates
- Change the mapping of OIDC token claims to certificate fields
- Create longer certificate chains, with multiple intermediate CAs
- Use SSH certificate extensions like `force-command` or `source-address`
- Add conditionals around a certificate's parameters, and fail if they are not met

## On This Page

- [Template Syntax Overview](#template-syntax-overview)
- [Time formatting](#time-formatting)
- [Configuring `step-ca` to Use Templates](#configuring-step-ca-to-use-templates)
- [X.509 Templates](#x509-templates)
- [ASN.1 Values](#asn1-values)
- [SSH Templates](#ssh-templates)
- [Basic X.509 Template Examples](#basic-x509-template-examples)
- [Advanced X.509 Template Examples](#advanced-x509-template-examples)
- [SSH Template Examples](#ssh-template-examples)
- [Even More Templates](#even-more-templates)

## Template Syntax Overview

Certificate templates are JSON documents
that describe the most important properties in the final certificate or certificate request.
They are [Go `text/template` files](https://golang.org/pkg/text/template/).
[Sprig functions](http://masterminds.github.io/sprig/) are available inside the templates.
A few custom [functions for ASN.1 encoding](#asn1-values) and [time formatting](#time-formatting) are also available.

<Alert severity="warning">
  <div>
    <strong>Warning: Always wrap values in <code>toJson</code></strong><br />
    In the templates on this page, variables are pulled into templates using <code>{`{{`} toJson .variableName {`}}`}</code> 
    to sanitize the value of the variable.
    When using templates, you must sanitize all variables using <code>toJson</code> to avoid template injection vulnerabilities.
  </div>
</Alert>

There are [default X.509](https://github.com/smallstep/crypto/blob/master/x509util/templates.go)
and [SSH](https://github.com/smallstep/crypto/blob/master/sshutil/templates.go)
templates hardcoded into `step-ca`.

### Time formatting

In addition to the time formatting functions offered by [Sprig](http://masterminds.github.io/sprig/),
`step-ca` has added some additional convenience functions for X.509 and SSH templates:

| Function | Description |
|----------|-------------|
| `toTime 1719970524` | Returns a `time.Time` in UTC from a Unix epoch. |
| `formatTime (now)` | Returns the UTC time as an RFC3339-formatted string.<br />Example output: `2006-01-02T15:04:05Z07:00` |
| `parseTime` | Returns the current time in UTC. |
| `parseTime "2024-07-03T01:30:39Z"` | Parses a time string using RFC3339 format and returns a `time.Time` object. |
| `parseTime "time.UnixDate" "Tue Jul  2 18:31:04 PDT 2024"` | Parses a time string using the `time.UnixDate` layout.<br />Returns a `time.Time` object in UTC. |
| `parseTime "time.UnixDate" "Tue Jul  2 18:31:04 PDT 2024" "America/Los_Angeles"` | Parses a time string using the `time.UnixDate` layout and a specified [time zone identifier](https://en.wikipedia.org/wiki/List_of_tz_database_time_zones), returning a `time.Time` object. |
| `mustParseTime` | Same as `parseTime` but returns an error if the time could not be parsed. |
| `toTimeLayout "RFC3339"` | Returns the [predefined layout string](https://pkg.go.dev/time#pkg-constants).<br />Example output: `2006-01-02T15:04:05Z07:00` |
| `toTimeLayout "time.UnixDate"` | Example output: `Mon Jan _2 15:04:05 MST 2006` |


## Configuring `step-ca` to Use Templates

How you add templates to `step-ca` depends on
whether you have enabled [remote provisioner management](./provisioners.mdx#remote-provisioner-management).

Remote provisioner management is disabled by default.

### Adding a template (without remote provisioner management)

Within the provisioner configuration block of `$STEPPATH/config/ca.json`,
certificate templates can be set
under the property `"options"`.
The following snippet shows a provisioner with custom X.509 and SSH templates:

```json
{
  "type": "JWK",
  "name": "jane@doe.com",
  "key": {
      "use": "sig",
      "kty": "EC",
      "kid": "lq69QCCEwEhZys_wavar9RoqRLdJ58u_OGzJK0zswSU",
      "crv": "P-256",
      "alg": "ES256",
      "x": "pt7T0n98qREZUkyUX6b4kXJ5FkJlIdiMfJaLFclZIng",
      "y": "Pw1y1xqe4g4YARwyBSkEkcjNrtPYxdKlYDLI512t2_M"
  },
  "encryptedKey": "eyJhbGciOiJQQkVTMi1IUzI1NitBMTI4S1ciLCJjdHkiOiJqd2sranNvbiIsImVuYyI6IkEyNTZHQ00iLCJwMmMiOjEwMDAwMCwicDJzIjoiQ1dWZG5zWTR2bGZJbG9BQ1dOaUdNUSJ9.12dowlkvESpxJgrNJgP2ELDQz750HSh2w6Ux6BmatBE5-ybAJFFO7g.1cjU2-CTrV3gbUE7.m8a95nv4qLnN_K_PG7lzgzYXBGnw_aHCf-znJ34AZxzPy2QDGGEjN_V0jX3kvHH9AIg3cs8I8NRm__RDm2iezU5AhPoAHaqnPnZdKh0ReBZ4hNpYXUHlTPf4fRaCXXDQiKatxNzCMBpyqKpudf3xYUzZPRNMN78WM0ZeIzmv_jFzbryOpxD8bJ3Bnxa4e8Am_pPdAANHphodlKN2nDr4701OLKgitImm8RoA20sWdAI_LkTS_Abk_TqBo_3qOGdjmnRBtATFSu3BdQw5wZMjywfwCWKXUK_OUt-cjVIe11xUT43SoE8fR2GJJEKomAHP0vn0MUUMqY9P9icUejw.eEYI_H7WfrYDL4yhsnsJxg",
  "claims": {
    "enableSSHCA": true
  }
  "options": {
    "x509": {
      "templateFile": "templates/certs/x509/leaf.tpl",
      "templateData": {
        "OrganizationalUnit": "Engineering Team"
      }
    },
    "ssh": {
      "templateFile": "templates/certs/ssh/host.tpl"
    }
  }
}
```

- **options**: object that allows configuration of provisioner options e.g. templates.

  - **x509** or **ssh**: object for configuring X.509 or SSH certificate template options.

    - **templateFile**: path to a template stored on disk. You have a few options for how to define your path:

        - **_absolute path_**:  e.g. `/home/mariano/path/to/file.ptl`
        - **_relative to `$(step path)`_**: e.g. `templates/certs/x509/leaf.tpl` the actual
          location of which would be `$(step path)/templates/certs/x509/leaf.tpl`.
        - **_relative to the execution directory of `step-ca`_**: e.g. `./path/to/file.tpl` or `../path/to/file.tpl`

    - **templateData**: defines variables that can be used in the template.
      In the example above, you are able to use the defined organizational unit as the variable `{{ .OrganizationalUnit }}`,
      for example in a template like:

        ```go
        {
            "subject": {
                "organizationalUnit": {{ toJson .OrganizationalUnit }},
                "commonName": {{ toJson .Subject.CommonName }}
            },
            "sans": {{ toJson .SANs }},
            "keyUsage": ["digitalSignature"],
            "extKeyUsage": ["serverAuth", "clientAuth"]
        }
        ```

    - **template**: set the full template in a string. The value can be the
      string representation of a JSON object, or you encoded in Base64. For
      example: 

        ```go
        {
            "x509": {
                "template": "{{ toJson .Insecure.CR }}",
            }
        }
        ```

        Or using Base64:

        ```go
        {
            "x509": {
                "template": "e3sgdG9Kc29uIC5JbnNlY3VyZS5DUiB9fQ==",
            }
        }
        ```

### Adding a template via remote provisioner management

You can use [`step ca provisioner update`](https://smallstep.com/docs/step-cli/reference/ca/provisioner/update/)
to read a template file
which will then be stored in the database for use by `step-ca`.
For example:

```
step ca provisioner update cicd --x509-template ./templates/cicd.tpl
step ca provisioner update google --ssh-template ./templates/google.tpl
```

See [`step ca provisioner update`](https://smallstep.com/docs/step-cli/reference/ca/provisioner/update/) for more options.

## X.509 Templates

X.509 templates can be used in two places:
1. In a CLI CA, via [`step certificate create`](../step-cli/reference/certificate/create/) or [`step certificate sign`](../step-cli/reference/certificate/sign/).
2. In a [`step-ca` server configuration](./configuration.mdx).

Here's what the default X.509 [leaf certificate template](https://github.com/smallstep/crypto/blob/162770cad29063385cb768b0191814e4c6a94e45/x509util/templates.go#L98) looks like:

```go
{
	"subject": {{ toJson .Subject }},
	"sans": {{ toJson .SANs }},
{{- if typeIs "*rsa.PublicKey" .Insecure.CR.PublicKey }}
	"keyUsage": ["keyEncipherment", "digitalSignature"],
{{- else }}
	"keyUsage": ["digitalSignature"],
{{- end }}
	"extKeyUsage": ["serverAuth", "clientAuth"]
}
```

### X.509 Template Fields

The fields available in an X.509 template
map to [X.509 v3 certificate fields](https://datatracker.ietf.org/doc/html/rfc5280).
See [the complete list of fields supported in `step-ca` templates](https://github.com/smallstep/crypto/blob/master/x509util/certificate.go#L16).

### X.509 Template Variables

<Alert severity="info" id="star11">
  <div>
    <strong>A note on <code>.Insecure</code> variables</strong><br />
    In templates, some variables are prefixed with <code>.Insecure</code>.
    They contain information that has not been cryptographically signed
    by a source that the CA trusts.
    For example, the <code>.Insecure.CR</code> map holds the user-supplied Certificate Request.
  </div>
</Alert>

Here are some variables available in X.509 certificate templates:

- **.Subject**:
  The subject that was passed in to `step certificate` or `step ca certificate`. Specifically,
  `.Subject.CommonName` contains the Common Name for the certificate. By default, a passed-in subject
  value must match a value from a trusted source in order to be added to the certificate.

- **.SANs**:
  Subject Alternative Names.
  This is a list of maps containing SANs for the certificate.
  Unless SANs are specified (using the `--san` flag, for example),
  the `.Subject.CommonName` is the default SAN. By default, a passed-in subject
  value must match a value from a trusted source in order to be added to the certificate.

- **.Token**:
  If a signed token was used to obtain the certificate 
  —for example, with the JWK provisioner—
  this property contains the payload of that token.

- **.AuthorizationCrt**:
  For provisioners that use certificates to authorize requests (eg. the X5C provisioner),
  this is the certificate used to authorize the current certificate request with the CA.
  The client has proven posession of this certificate's private key.
  For an X.509 authorization certificate, the `.AuthorizationCrt` is a [`crypto/x509` Certificate](https://pkg.go.dev/crypto/x509#Certificate).

- **.AuthorizationChain**:
  For provisioners that use certificates to authorize requests (eg. the X5C provisioner),
  this is an array of the certificate chain from the request.
  This chain connects the authorization certificate to the root CA configured in the provisioner.

- **.Insecure** These variables are marked insecure because they contain client-supplied data that is not signed by a trusted party.

- **.Insecure.CR**<Reference id="star11" marker="*" />: ☠️
  This holds the Certificate Request (CSR) received from the client.
  `.Insecure.CR` is a [`crypto/x509` CertificateRequest](https://pkg.go.dev/crypto/x509#CertificateRequest).
  How `step-ca` handles a Certificate Request depends on the provisioner.
  While a CSR is always passed to step-ca (often alongside a signed token),
  in most cases _only the public key value in the CSR is used by step-ca_.
  These properties are marked _insecure_ because CSRs are not explicitly authenticated by step-ca.
  Instead, step-ca will authenticate the signed values from OIDC tokens, JWK tokens, cloud IIDs,
  and the validated SANs from ACME orders.
  For ACME, step-ca validates that the CSR's subject and SANs only contain values that are in the validated ACME order.

- **.Insecure.CR.DNSNames**:
  The DNS Name Subject Alternative Names (SANs) provided in the CSR

- **.Insecure.CR.IPAddresses**:
  The IP Address SANs provided in the CSR

- **.Insecure.CR.URIs**:
  The URI SANs provided in the CSR

- **.Insecure.CR.EmailAddresses**:
  The Email Address SANs provided in the CSR

- **.Insecure.CR.Subject**:
  The CSR subject field.

- **.Insecure.CR.Subject.CommonName**:
  The Common Name (CN) from the CSR subject

- **.Insecure.CR.Subject.ExtraNames**:
  The Extra Names from the CSR subject.
  This is an array of all subject distinguished names (DNs) in the CSR.
  Each contains an OID (`type`) and a value (`value`).

- **.Insecure.CR.RawSubject**:
  The original subject asn.1 value from the CSR.
  Use this if your application requires that the certificate subject and CSR subject match exactly.
  (Because `step-ca` may re-encode the CSR subject when creating the certificate subject,
  these values may not match byte-for-byte)

- **.Insecure.CR.PublicKey**:
  The public key provided in the certificate request.
  You can check the request's key type with a conditional, like `{{- if typeIs "*rsa.PublicKey" .Insecure.CR.PublicKey }}`.
  You can check the request's key size with a conditional, like `{{- if lt .Insecure.CR.PublicKey.Size 384 }}`.

- **.Insecure.User**:
  This property holds user-supplied data from the certificate request.
  Users can supply arbitrary values using `--set` or `--set-file` flags in `step ca certificate`.

You can also import values
from the `"templateData"` object
in your provisioner's [configuration block](#configuring-the-ca-to-use-templates).

### ASN.1 Values

_This is section is for advanced use cases that require
custom extensions or special encodings of data inside certificates.
Most users are best served by `step-ca`'s higher-level template functions._

The templating system in `step-ca` includes a few functions for encoding ASN.1 values.

ASN.1 (Abstract Syntax Notation 1) is a standard
from the 1980s that define the data structures
and format of an X.509 certificate.
X.509 certificates are encoded using ASN.1,
then serialized into binary using DER (Distinguished Encoding Rules)
before being (optionally) PEM-encoded with Base64.

Use these functions to populate custom certificate OID `extensions`:

```go
"extensions": [
  {"id": "1.2.3.4", "critical": false, "value": {{ asn1Enc "int:3848281" | toJson }}}
]
```

When applied to template variables, these functions enable dynamic OID extensions:

```go
{
	"subject": {{ toJson .Subject }},
	"sans": {{ toJson .SANs }},
{{- if typeIs "*rsa.PublicKey" .Insecure.CR.PublicKey }}
	"keyUsage": ["keyEncipherment", "digitalSignature"],
{{- else }}
	"keyUsage": ["digitalSignature"],
{{- end }}
	"extKeyUsage": ["serverAuth", "clientAuth"],
	"extensions": [
		{"id": "1.2.3.4", "value": {{ asn1Marshal .AuthorizationCrt.NotAfter | toJson }}},
		{"id": "1.2.3.5", "value": {{ asn1Set (asn1Marshal (first .Insecure.CR.DNSNames) "utf8") (asn1Enc "int:123456") | toJson }}},
		{"id": "1.2.3.6", "value": {{ asn1Seq (asn1Enc "YubiKey") (asn1Enc "int:123456") | toJson }}}
	]
}
```

Let's walk through one line of this template:

```go
{"id": "1.2.3.6", "value": {{ asn1Seq (asn1Enc "YubiKey") (asn1Enc "int:123456") | toJson }}}
```

To render this line of the template:

1. `asn1Enc "YubiKey"` encodes "YubiKey" as an ASN.1 Printable string, and returns the Base64
2. `asn1Enc "int:123456"` encodes 123 as an ASN.1 Integer, and returns the Base64
3. `asn1Seq` gets the resulting Base64 strings, decodes them, creates an ASN.1 SEQUENCE, and returns the Base64 of the SEQUENCE.
4. Finally, `toJson` returns a JSON string representation of the Base64

#### asn1Enc

Encodes a string into an ASN.1 value.

A data type can be supplied as a prefix,
and ASN.1 Printable is the default data type:

```go
asn1Enc "int:123"
asn1Enc "oid:1.2.3.4"
asn1Enc "foo"
asn1Enc .Subject.CommonName
```

This function supports the data types described [here](https://github.com/smallstep/crypto/blob/afcd4fc89b2cc36c590909908fa6ac1523fdcc61/x509util/extensions.go#L525):

- **printable**: "printable:abcfoo" (or just "abcfoo")
- **int**: "int:12324"
- **oid**: "oid:1.2.3.4"
- **utf8**: "utf8:foobar"
- **ia5**: "ia5:abcfoo"
- **numeric**: "numeric:01 02 03345" (multiple space-separated ints)
- **utc**: "utc:2023-03-29T02:03:57Z" or "utc:2023-04-20 15:28:27.909088 -0700 PDT"
- **generalized**: "generalized:2023-03-29T02:03:57Z" or "generalized:2023-04-20 15:28:27.909088 -0700 PDT"
- **bool**: "bool:true" or "bool:false"
- **raw**: a special type that accepts a Base64 string

For more details on ASN.1 types and their meanings, see [ASN.1 Types](https://www.oss.com/asn1/resources/asn1-made-simple/asn1-quick-reference.html#Types).

#### asn1Marshal

`asn1Marshal` simplifies the encoding of Go values into ASN.1.
For example, if you want to encode the Not After value in an X5C authorization certificate,
without converting it to a string first, `asn1Marshal .AuthorizationCrt.NotAfter` will do the trick.

`asn1Marshal` imitates Go's [`asn1.MarshalWithParams`](https://pkg.go.dev/encoding/asn1#MarshalWithParams) function.

```go
asn1Marshal .Token.iss
asn1Marshal .AuthorizationCrt.NotAfter "utc"
```

The second parameter is the ASN.1 data type.
It will use Go's default transformation if no data type is supplied.

#### asn1Seq

Creates an ASN.1 `SEQUENCE` of values.

```go
asn1Seq (asn1Enc "foo") (asn1Enc "int:123") ...
```

#### asn1Set

Creates an ASN.1 `SET` of values.

```go
asn1Set (asn1Enc "foo") (asn1Enc "int:123") ...
```

## SSH Templates

`step-ca` also supports SSH certificate templates.
Here is `step-ca`'s default [SSH certificate template](https://github.com/smallstep/crypto/blob/162770cad29063385cb768b0191814e4c6a94e45/sshutil/templates.go#L144):

```go
{
	"type": {{ toJson .Type }},
	"keyId": {{ toJson .KeyID }},
	"principals": {{ toJson .Principals }},
	"extensions": {{ toJson .Extensions }},
	"criticalOptions": {{ toJson .CriticalOptions }}
}
```

### SSH Template Fields

The [OpenSSH certificate protocol spec](https://github.com/openssh/openssh-portable/blob/master/PROTOCOL.certkeys) defines SSH certificate fields and the available Critical Options and Extensions.
Third parties can also add custom extensions.
See [the complete list of fields supported by `step-ca` SSH template](https://github.com/smallstep/crypto/blob/master/sshutil/certificate.go#L16).

### SSH Template Variables

Here are the most relevant parameters available in SSH certificate template:
- **.Token**:
  This property offers the best opportunity for injecting signed, secure data into the certificate.
  If a token was used to obtain the certificate,  
  this property contains token payload used in the certificate request.
  For example, when using an OAuth ID token,
  `.Token.email` will contain the user's email address.
  To add custom data to `.Token`, you could use custom OAuth claims, or sign your own JWTs.
  
- **.Extensions**: is a map containing extensions.
  The default value for `Extensions` is:

  ```go
  {
    "permit-X11-forwarding":   "",
    "permit-agent-forwarding": "",
    "permit-port-forwarding":  "",
    "permit-pty":              "",
    "permit-user-rc":          ""
  }
  ```

- **.CriticalOptions**: is a map containing critical options.
  It is empty by default.

- **.Principals**: For users, this value is derived from the OIDC token
  (when using the [OIDC provisioner](provisioners.mdx#oauthoidc-single-sign-on)).
  For hosts, it is derived from the Instance Identity Document
  (when using the [Cloud provisioners](provisioners.mdx#cloud-provisioners)).

- **.KeyID**:
  The key ID being requested.

- **.Type**:
  The type of SSH certificate being requested.
  This will be `user` or `host`.

- **.Insecure.CR**<Reference id="star11" marker="*" />:
  SSH certificate requests to `step-ca` are not CSRs in the X.509 sense.
  So, `step-ca` creates a virtual certificate request,
  and that's what this variable represents.

- **.Insecure.CR.Principals**: If you trust a host to register its own custom SANs
  (for example, when using the IID provisioner),
  then the host can pass several `--principal` values to [`step ssh certificate`](../step-cli/reference/ssh/certificate) when registering the host,
  and use `.Insecure.CR.Principals` to access those from a template.

- **.Insecure.CR.Type**:
  The type of SSH certificate being requested.
  This will be `user` or `host`.

- **.Insecure.CR.KeyID**:
  The key ID being requested.

- **.Insecure.User**: This property holds user-supplied data from the certificate request.
  Users can supply arbitrary values using `--set` or `--set-file` flags in [`step ssh certificate`](../step-cli/reference/ssh/certificate).

You can also import parameter values
from your provisioner's [configuration block](#configuring-the-ca-to-use-templates).

<Alert severity="warning">
  <div>
    <strong>An OIDC Caveat</strong><br />
    If you've added an OIDC admin user to your CA configuration,
    and you add an SSH certificate template,
    you will lose the OIDC provisioner admin privilege of being able to supply arbitrary <code>--principal</code> values when requesting an SSH certificate.
    This is because the CA usually uses a different <a href="https://github.com/smallstep/crypto/blob/162770cad29063385cb768b0191814e4c6a94e45/sshutil/templates.go#L152">default template for admin users</a>.
  </div>
</Alert>

### Basic X.509 Template Examples

<Alert severity="info">
  <div>
    <strong>Here's an easy way to test X.509 templates</strong><br />
    You can create <a href="https://smallstep.com/docs/step-ca/certificate-authority-core-concepts#online-and-offline-x509-certificate-authority">a stateless offline CA</a> with <a href="https://smallstep.com/docs/step-cli/reference/certificate"><code>step certificate</code></a>,
    and pass <code>--template &lt;path&gt;</code> to the <a href="https://smallstep.com/docs/step-cli/reference/certificate/create"><code>step certificate create</code></a> or <a href="https://smallstep.com/docs/step-cli/reference/certificate/sign"><code>step certificate sign</code></a> subcommands.
  </div>
</Alert>

#### Leaf Certificates

The most common type of certificate you'll want to create is a leaf (or end-entity)
certificate; this is the type of certificate that your servers or clients will
use.

The default leaf certificate template is:

```go
{
	"subject": {{ toJson .Subject }},
	"sans": {{ toJson .SANs }},
{{- if typeIs "*rsa.PublicKey" .Insecure.CR.PublicKey }}
	"keyUsage": ["keyEncipherment", "digitalSignature"],
{{- else }}
	"keyUsage": ["digitalSignature"],
{{- end }}
	"extKeyUsage": ["serverAuth", "clientAuth"]
}
```

We will explain what each block does, but first, let's look at what a rendered
template might look like. Imagine that you run the following command to create
a certificate that has `jane@doe.com` as an email SAN.

```shell
step ca certificate jane@doe.com jane.crt
```

The rendered template (from which the X.509 certificate will be generated and
signed) is:

```go
{
    "subject": {
        "commonName": "jane@smallstep.com"
    },
    "sans": [{"type": "email", "value": "jane@smallstep.com"}],
    "keyUsage": ["digitalSignature"],
    "extKeyUsage": ["serverAuth", "clientAuth"]
}
```

Going back to the template above, we can see that the template has blocks
delimited by `{{` and `}}`. These are called **_actions_** - **_actions_** are
data evaluations or control structures. The ones in the default template are:

- `{{ toJson .Subject }}`: renders `.Subject` as JSON. `toJson` is a function in
Sprig that encodes the passed item into JSON. `.Subject` is a variable available
in all templates that contains the `<subject>` parameter passed in the CLI, in
this case, `jane@smallstep.com`, and to be more precise, this value is available
in `.Subject.CommonName`.

- `{{ toJson .SANs }}`: renders `.SANs` (Subject Alternative Names) as JSON.
The variable `.SANs` is also available in all templates and contains the list
of `SANs` passed from the CLI.  If no `SANs` are specified, the
`.Subject.CommonName` will be used as a default `SAN` (e.g.
`jane@smallstep.com` in our example). If you add more `SANs` using the
flag `--san`, `step-ca` will auto-assign the correct SAN `type` (`dns`, `ip`,
`uri`, or `email`).

- `{{- if typeIs "*rsa.PublicKey" .Insecure.CR.PublicKey }}`: defines a
condition based on the key type in the certificate request. `typeIs`
is a Sprig function that returns true if the type of the data in
`.Insecure.CR.PublicKey` matches `*rsa.PublicKey`, this is the Go specific type
for RSA public keys. If the condition is true, the `keyUsage` is set to
`keyEncipherment` and `digitalSignature`, otherwise just `digitalSignature`. 
`keyEncipherment` is used in the RSA key exchange protocol,
and it must only be set if an RSA key is used. `.Insecure.CR` is a structure that
represents the certificate (signing) request or CSR, from it we can extract
SANs, the subject, extensions, etc. 

Finally we also set the extended key usage `serverAuth` and `clientAuth` so the
certificate can be used in a server application or in a client for mTLS.

#### Intermediate Certificates

An intermediate certificate is a certificate that can be used to sign another
certificate, and it has itself been signed by another intermediate certificate or by
a root certificate.

The default template for an intermediate certificate is:

```go
{
	"subject": {{ toJson .Subject }},
	"keyUsage": ["certSign", "crlSign"],
	"basicConstraints": {
		"isCA": true,
		"maxPathLen": 0
	}
}
```

This template is most commonly used when initializing a CA.

The `keyUsage` **_certSign_** allows a certificate to sign other certificates.
**_crlSign_** allows a certificate to sign Certificate Revocation Lists or CRLs.

In `basicConstraints` we say that this certificate is a CA, and the path length
constraint, `maxPathLen`, is maximum number of non-self-issued intermediate
certificates that may follow this certificate in a valid certification path. An
intermediate with a `maxPathLen` set to `0` won't be able to sign another
intermediate certificate. To be precise, it can sign it, but the new
intermediate won't be trusted by clients, so it won't be useful.

Knowing this we can also guess that the intermediate certificate's issuer had at
least a `maxPathLen` of `1`. So if you want to use an intermediate certificate
that can sign other intermediates, make sure to set more permissive `maxPathLen`
in the root and intermediate certificate used.

The command [`step certificate create`](../step-cli/reference/certificate/create) with the `--profile intermediate-ca` flag
uses the template above, but if you want to create an intermediate with a custom
template you can run:

```shell
step certificate create --template intermediate.tpl \
--ca ~/.step/certs/root_ca.crt --ca-key ~/.step/secrets/root_ca_key \
"ACME Intermediate CA" intermediate_ca.crt intermediate_ca_key
```

#### Root Certificates

A root certificate is a self-signed certificate used to sign other certificates.
The default root certificate template is:

```go
{
	"subject": {{ toJson .Subject }},
	"issuer": {{ toJson .Subject }},
	"keyUsage": ["certSign", "crlSign"],
	"basicConstraints": {
		"isCA": true,
		"maxPathLen": 1
	}
}
```

Here we are specifying that the **_issuer_** is equivalent to the **_subject_**, and the `maxPathLen` is set to
`1`, so it can sign intermediate certificates with `maxPathLen` set to `0`. If
you want to allow intermediates to sign other intermediates, you need to set the
`maxPathLen` to at least `2`. It's also possible to not limit the number of
intermediates that can follow this certificate if we set `maxPathLen` to `-1`,
and then create intermediates that set a specific limit, i.e. `0` for those that
can sign only leaf certificates and `1` for those that can sign at most one downstream
intermediate certificate.

The command [`step certificate create`](../step-cli/reference/certificate/create) with the `--profile root-ca` flag uses the
above template. To create a custom root certificate, you can run:

```shell
step certificate create --template root.tpl "ACME Root CA" root_ca.crt root_ca_key
```

<Alert severity="info">
  <div>
    It is not possible to use <Code>step-ca</Code> to sign root certificates.
	And, <Code>step-ca</Code> cannot sign intermediates directly from its root for clients.
  </div>
</Alert>


### Advanced X.509 Template Examples

In the previous section,
we learned how to create and use the basic templates,
but we've just scratched the surface of what's possible.
With templates, you can customize and parameterize every aspect of an X.509 
or SSH certificate.

Below, we'll walk through a few advanced templating examples.

#### Certificate Request

Let's start with one of the shortest templates:

```go
{{ toJson .Insecure.CR }}
```

This template produces a signed certificate that contains all the information
present in the certificate request (with a few caveats). All SANs and
extensions present in the certificate request will be in the final certificate.

The only modifications that a signed certificate might have (over a CSR), would be in the
certificate subject on `step-ca` if a template is provided in the `ca.json`, and
it will set the Subject Alternative Name extension to critical if the subject is
empty.

#### User-Provided Values in Signing Requests

In `step-ca`, X.509 templates can also be parameterized with values
provided by `step` at certificate creation time. A common use case for
values is when you receive a CSR from another team, or a CSR embedded in
hardware, and you need to define a SAN for it.

For example, below is an X.509 template that accepts the user-supplied value `dnsName`
but it falls back to the default leaf template value if it's not present:

```go
{
	"subject": {{ toJson .Subject }},
{{- if .Insecure.User.dnsName }}
	"dnsNames": {{ toJson .Insecure.User.dnsName }},
{{- else }}
	"sans": {{ toJson .SANs }},
{{- end }}
{{- if typeIs "*rsa.PublicKey" .Insecure.CR.PublicKey }}
	"keyUsage": ["keyEncipherment", "digitalSignature"],
{{- else }}
	"keyUsage": ["digitalSignature"],
{{- end }}
	"extKeyUsage": ["serverAuth", "clientAuth"]
}
```

You can then use `step` to sign a CSR like so:

```shell-session nocopy
$ step ca sign --set "dnsName=backend.example.com" input.csr output.crt
# Or
$ echo '{"dnsName": "backend.example.com"}' > vars.json
$ step ca sign --set-file vars.json input.csr output.crt
```

Both flags, `--set <name=value>` and `--set-file <path>` are available in
[`step ca certificate`](../step-cli/reference/ca/certificate) and [`step ca sign`](../step-cli/reference/ca/sign).
If you need to pass more than one value,
you can use `--set` multiple times or use a JSON file with multiple properties.

It's worth mentioning the while we used `"dnsNames"` instead of `"sans"` in the example above, both can
be used. `"dnsNames"` is a list of strings (or just one string if only one is
required), while `"sans"` is an list of maps:

```go
[
	{"type": "dns", "value": "backend.example.com"},
	{"type": "email", "value": "jane@example.com"},
	{"type": "ip", "value": "10.0.1.10"},
	{"type": "uri", "value": "https://backend.example.com/root.crt"},
]
```

The list `.SANs` is generated by the provisioner,
containing the values of the trusted names.

Besides `"dnsNames"`, you can also use `"emailAddresses"`, `"ipAddresses"`, and
`"uris"`.

#### Adding Name Constraints

Name constraints are useful in intermediate certificates when you want to limit
the validity of certificates that an intermediate can sign. If we want to only
allow DNS name like \*.example.com we can generate an intermediate with the
template:

```go
{
    "subject": {{ toJson .Subject }},
    "keyUsage": ["certSign", "crlSign"],
    "basicConstraints": {
        "isCA": true,
        "maxPathLen": 0
    },
    "nameConstraints": {
        "critical": true,
        "permittedDNSDomains": ["example.com"]
    }
}
```

Given a root certificate and a key, you can generate the intermediate with:

```shell
step certificate create --template intermediate.tpl --ca root_ca.crt --ca-key root_ca_key \
     "Intermediate CA" intermediate.crt intermediate.key
```

Besides `"permittedDNSDomains"`, the `"nameConstraints"` property accepts all
the following properties:

```go
{
    ...
	"nameConstraints": {
		"critical": false,
		"permittedDNSDomains": ["doe.com"],
		"excludedDNSDomains": ["doe.org"],
		"permittedIPRanges": ["1.2.3.0/24"],
		"excludedIPRanges": ["3.2.1.0/24"],
		"permittedEmailAddresses": ["jane@doe.com"],
		"excludedEmailAddresses": ["jane@doe.org"],
		"permittedURIDomains": ["https://doe.com"],
		"excludedURIDomains": ["https://doe.org"]
    }
    ...
}
```

Remember that in certificate templates, if an array only has one member, you can
write it as a string:

```go
{
    ...
	"nameConstraints": {
        "critical": true,
        "permittedDNSDomains": "example.com"
    }
    ...
}
```

#### Arbitrary X.509 Extensions

SANs, key usages, extended key usages, basic constraints, and name constraints,
are all extensions in an X.509 certificate. Templates provide an
easy way for assigning extensions without the need of using the actual extension
bytes.

The same thing is also possible with top-level certificate template properties like:

- **unknownExtKeyUsage**: defines custom extended key usages using ASN.1
object identifiers; this is useful if the templates do not support a string
version of the extended key usage [(RFC 5280, 4.2.1.12)](https://tools.ietf.org/html/rfc5280#section-4.2.1.12).

- **ocspServer**: sets a list of OCSP servers in the Authority Information
Access extension [(RFC 5280, 4.2.2.1)](https://tools.ietf.org/html/rfc5280#section-4.2.2.1).

- **issuingCertificateURL**: defines the issuing certificate URL in the Authority
Information Access extension [(RFC 5280, 4.2.2.1)](https://tools.ietf.org/html/rfc5280#section-4.2.2.1).

- **crlDistributionPoints**: defines URLs with the certificate revocation
list [(RFC 5280, 4.2.1.13)](https://tools.ietf.org/html/rfc5280#section-4.2.1.13)).

- **policyIdentifiers**: defines a list of ASN.1 object identifiers with
certificate policies [(RFC 5280, 4.2.1.4)](https://www.rfc-editor.org/rfc/rfc5280#section-4.2.1.4).

But if you need to create your own extension, or use an unsupported one, you can
also write a custom extension like:

```go
{
  ...
  "extensions": [
    {"id": "1.2.3.4", "critical": false, "value": "Y3VzdG9tIGV4dGVuc2lvbiB2YWx1ZQ=="}
  ]
  ...
}
```

The value of the extension is the Base64 encoding of the
actual ASN.1 bytes that go into that extension.

For a more human-readable template,
you can also use [ASN.1 functions](#asn1-values) in the extension `value` field.
We'll do that in the next example.

#### Deep dive: Certificate Policies

X.509 Certificate Policies define policy constraints of a certificate.
They help relying parties determine the trustworthiness of a certificate,
and how to use it in practice.

For example, in the Web PKI, the Policy OID `2.23.140.1.2.1` is used to distinguish a certificate that meets the [CA/Browser Forum Baseline Requirements](https://cabforum.org/working-groups/server/baseline-requirements/requirements/) for Domain Validation.

In an internal PKI, a large organization might use a Certificate Policy to detail to a relying party how the CA verified the identity of the certificate requestor, or to approve a certificate for specific applications.
But, this sort of use case is very niche.

A Certificate Practices Statement (CPS) is type of Certificate Policy that references a document describing a CA's operational practices and security controls.

Here's [an example of a CPS from Let's Encrypt](https://letsencrypt.org/documents/isrg-cp-cps-v5.7/).

Let's add a policy extension with a CPS to an X.509 template.
We'll need to construct some ASN.1 for this.

```go
{
  ...
  "extensions": [
    {
      "id": "2.5.29.32",
      "value": {{
        asn1Seq
          (asn1Seq
            (asn1Enc "oid:1.3.6.1.4.1.99999.1.1.1")
            (asn1Seq (asn1Seq (asn1Enc "oid:1.3.6.1.5.5.7.2.1") (asn1Enc "ia5:http://example.com/cps")))
          )
        | toJson
      }}
    }
  ]
  ...
}
```

First, the public OID `2.5.29.32` represents the Certificate Policies extension.
In the value for this extension, we have two policies.
The first references Policy OID `1.3.6.1.4.1.99999.1.1.1`, a custom policy OID defined by our example organization.
The second policy contains both the well-defined OID  `1.3.6.1.5.5.7.2.1` [representing a CPS pointer](https://www.rfc-editor.org/rfc/rfc5280.html#section-4.2.1.4), and the CPS pointer `http://example.com/cps`.

#### X.509 OpenVPN certificates

One interesting use case for certificate templates is the signing of
[OpenVPN](https://openvpn.net) certificates. These certificates require specific
key usages not available in the default templates.

This is a template you can use in a provisioner signing OpenVPN client certificates:

```go
{
  "subject": {"commonName": {{ toJson .Insecure.CR.Subject.CommonName }}},
  "sans": {{ toJson .SANs }},
  "keyUsage": ["digitalSignature", "keyAgreement"],
  "extKeyUsage": ["clientAuth"]
}
```

And the following template can be used for a provisioner signing OpenVPN server
certificates:

```go
{
  "subject": {{ toJson .Subject }},
  "sans": {{ toJson .SANs }},
  "keyUsage": ["digitalSignature", "keyEncipherment", "keyAgreement"],
  "extKeyUsage": ["serverAuth"]
}
```

A full configuration of `step-ca` and OpenVPN is available in our blog post
["Announcing X.509 Certificate
Flexibility"](https://smallstep.com/blog/x509-certificate-flexibility/)

### SSH Template Examples

#### GitHub SSH Certificates

With GitHub Enterprise Cloud or GitHub Enterprise Server, you can configure GitHub to use SSH certificates.
Specifically, GitHub will [trust an SSH Certificate Authority for your team](https://docs.github.com/en/free-pro-team@latest/github/setting-up-and-managing-organizations-and-teams/about-ssh-certificate-authorities).
But, to get it to work, you have to generate custom SSH certificates for your users
using a `login@github.com` extension,
where the value of the extension is their GitHub Username.
This custom extension value authenticates your users to GitHub Enterprise.
Which is great: The same certificates that let you SSH into your servers now also let you push code.

Here's an SSH template that supports the GitHub custom SSH certificate extension:

```go
{
	"type": {{ toJson .Type }},
	"keyId": {{ toJson .KeyID }},
	"principals": {{ toJson .Principals }},
	"criticalOptions": {{ toJson .CriticalOptions }},
{{ if .Token.ghu }}
	"extensions": {
	  "login@github.com": {{ toJson .Token.ghu }}
	}
{{ else }}
	"extensions": {{ toJson .Extensions }}
{{ end }}
}
```

To use this template, you'd need to add a `ghu` ("GitHub Username") custom claim to the token that you send the CA to authenticate your certificate request.

If you use an [OIDC provisioner](provisioners.mdx#oauthoidc-single-sign-on) with this template,
you can configure your identity provider to serve a custom claim labeled `ghu` in your ID token.
Our blog post ["Clever Uses of SSH Certificate Templates"](https://smallstep.com/blog/clever-uses-of-ssh-certificate-templates/) has more details on this option.


The [JWK](provisioners.mdx#jwk) and [Cloud](provisioners.mdx#cloud-provisioners) provisioners also use tokens.
Here's an example of a Bash test script that
decrypts your JWK provisioner key,
and uses it to sign a token that `step-ca` will accept for an SSH certificate:

```bash
#!/bin/bash
#
# This script is for testing purposes only.
#

# Your CA hostname and port
CA=ca.local:443

# Key ID: This is the "kid" value from your JWK provisioner configuration
KID=R0a0VGbbOe3j6ol5jOdV3qfiigjcezk0LG9K9Cp7mrg

# Issuer: The "name" of your JWK provisioner
ISS="carl@smallstep.com"

if [ "$#" -ne 2 ]; then
    name=$(basename $0)
    echo "Usage: $name <princiap> <github-username>"
    exit 1
fi

# Grab the key to encrypt
KEY=`curl --cacert ~/.step-ssh-templates/certs/root_ca.crt -s https://${CA}/1.0/provisioners/${KID}/encrypted-key | jq -r .key | step crypto jwe decrypt`

echo '{"step": {"ssh":{"certType": "user", "keyID": "'$1'"}}, "ghu":"'$2'"}' | step crypto jwt sign --key <(echo $KEY) --iss "$ISS" --aud "https://${CA}/1.0/sign" -sub $1 -exp $(date -v+5M +"%s")
```

Here's the script used in concert with the GitHub SSH template above:

```shell-session
$ TOKEN=$(./gh_token.sh carl tashian)
Please enter the password to decrypt the content encryption key: ...
$ echo $TOKEN | step crypto jwt inspect --insecure
{
  "header": {
    "alg": "ES256",
    "kid": "R0a0VGbbOe3j6ol5jOdV3qfiigjcezk0LG9K9Cp7mrg",
    "typ": "JWT"
  },
  "payload": {
    "aud": "https://localhost:4430/1.0/sign",
    "exp": 1606870196,
    "ghu": "tashian",
    "iat": 1606869896,
    "iss": "carl@smallstep.com",
    "jti": "6d62922871db260e54d97fe1f2561440177ae579e31baa954128e0fba155b4db",
    "nbf": 1606869896,
    "step": {
      "ssh": {
        "certType": "user",
        "keyID": "carl"
      }
    },
    "sub": "carl"
  },
  "signature": "RdYo70cCR7tMZBl8VLbxVpoCDlNED2wpRw8uPV1rNkDENBbXqml1h-TnWG23dJ4zKzPhAuO2Vk7HdOUC2q0mNg"
}
$ step ssh certificate carl github --token $TOKEN
✔ CA: https://localhost:4430
Please enter the password to encrypt the private key:
✔ Private Key: github
✔ Public Key: github.pub
✔ Certificate: github-cert.pub
✔ SSH Agent: yes
$ step ssh inspect github-cert.pub
github-cert.pub:
        Type: ecdsa-sha2-nistp256-cert-v01@openssh.com user certificate
        Public key: ECDSA-CERT SHA256:SdcgsNKaQbhYveanJYjmJk4eLN3+CBKUKkRGv4xYn5U
        Signing CA: ECDSA SHA256:MKwRQ/SDKk/pCJbbCk5bfhZACjSjv7uZXLyc5n4Wx6k
        Key ID: "carl"
        Serial: 886026644913671581
        Valid: from 2020-12-01T16:40:32 to 2020-12-02T08:41:32
        Principals:
                carl
        Critical Options: (none)
        Extensions:
                login@github.com tashian
```

In production, you would not want to hand out your JWK provisioner password.
But you could create a token server that interoperates with `step-ca` and injects secure values into the token. 

#### SSH Group Accounts

Let's say your organization has shared group accounts on your hosts (eg. "dba" or "devops").
You'd want to be able to issue people in those groups a certificate that contains their user principals ("carl", "carl@smallstep.com"),
plus principals for any group accounts they need access to.

Let's use the OIDC ID token to inject additional principals into an SSH user certificate.

First, configure a custom `groups` claim with your identity provider, and add the claim to the payload of the ID token.
In this example, we're assuming the `groups` claim contains a space-separated list of possible group accounts.

Then, use the following template to merge the group accounts with the user's own principals (derived from the `email` claim):
  ```go
  {
    "type": {{ toJson .Type }},
    "keyId": {{ toJson .KeyID }},
    "principals": {{ toJson ((concat .Principals (splitList " " .Token.groups)) | uniq) }},
    "criticalOptions": {{ toJson .CriticalOptions }},
    "extensions": {{ toJson .Extensions }}
  }
  ```

This is a good example of the use of [Sprig functions](https://masterminds.github.io/sprig/) in templates.

Finally, test out your flow with [`step ssh login`](../step-cli/reference/ssh/login), and use [`step ssh inspect`](../step-cli/reference/ssh/inspect) to check the principals of the certificate you're issued by the CA.

### Even More Templates

To delve deeper into certificate templates and all the options, the best source
of information is the code docs for the [go.step.sm/crypto/x509util
package](https://pkg.go.dev/go.step.sm/crypto/x509util):

* The [Certificate](https://pkg.go.dev/go.step.sm/crypto/x509util#Certificate)
object represents a certificate template with all its properties.

* The
[CertificateRequest](https://pkg.go.dev/go.step.sm/crypto/x509util#CertificateRequest)
object represents all properties for a CSR template that can be used in
[`step certificate create --csr`](../step-cli/reference/certificate/create).

* All key usages and supported extended key usages without using
`"unknownExtKeyUsage"` are available
[here](https://pkg.go.dev/go.step.sm/crypto/x509util#pkg-variables).

More information and more examples are available in the blog posts
["Announcing X.509 Certificate Flexibility"](https://smallstep.com/blog/x509-certificate-flexibility/)
and ["Clever Uses of SSH Certificate Templates"](https://smallstep.com/blog/clever-uses-of-ssh-certificate-templates/).
