When working with certificate in containers, you'll need to decide how and where and when to handle each of these tasks:

- **Root distribution**: Getting the container to trust the CA
- **Enrollment**: Issuing the service a new TLS certificate from the CA
- **Renewal**: Renewing the certificate when it nears expiry
- **Deployment**: Moving the certificate into place and signaling a certificate reload (or restarting the service)

There are several approaches one could take for full automation. Here are a few:

- **Self-contained**:
  With this approach, the official Docker image for the service is augmented to add certificate management functions, usually by overriding the `ENTRYPOINT`.
  While some might argue that this violates the single responsibility principle,
  we believe certificate management is well within the responsibility of a service that supports TLS.
  CA trust is bootstrapped when the image is built, and the root CA certificate is baked into the image.
- **Host-based**:
  With this approach, the unmodified, official Docker image for the service can be used.
  The host is responsible for renewing certificates
  and triggering a reload of certificate files (or restarting the containers) when they are renewed.
  Certificates can be made renewed from the host via volume mounts, or copied into the container.
  For ACME support, an ACME client binary on the host can be run inside the container's network namespace (via `nsenter`) in order to respond to ACME `HTTP-01` or `TLS-ALPN-01` challenges.
  This approach can leverage a systemd-based renewal timer (see the Linux tab for details).
  For root distribution, a volume mount can often be used to add the root CA certificate to the container's trust store,
  but some Docker images may still need to be augmented to trust the root CA ceritficate.
- **Sidecar**:
  Certificates are mounted via shared volume mounts,
  and a separate sidecar container is responsible for certificate enrollment, renewal, and deployment.
  Deployment can happen via an API call directly to the service
  (if it supports online certificate reloading via API),
  or by updating or restarting the service container via a [Docker socket proxy](https://github.com/tecnativa/docker-socket-proxy) call.
  The unmodified, official Docker image for the service can be used, however the image may still need to be augmented to trust the root CA ceritficate.

To support the broadest range of environments where containers are run,
**we prefer the self-contained approach**.
While it requires building a custom Docker image,
it solves the problems of root distribution, enrollment, renewal, and deployment
without requiring volume mounts or changes to the host environment.
